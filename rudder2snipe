#!/usr/bin/env python3
# rudder2snipe - Inventory Import
#
# ABOUT:
#   This program is designed to import inventory information from a
#   Rudder instance into snipe-it using api calls. For more information
#   about both of these products, please visit their respective
#   websites:
#       https://rudder.io
#       https://snipeitapp.com
#
# LICENSE:
#   MIT
#
# CONFIGURATION:
#   These settings are commonly found in the settings.conf file.
#
#   This setting sets the Snipe Asset status when creating a new asset. By default it's set to 4 (Pending).
#   defaultStatus = 4
#
#   You can associate snipe hardware keys in the [api-mapping] section, to a Rudder keys so it associates
#   the rudder values into snipe. The default example associates information that exists by default in both
#   Snipe and Rudder. The Key value is the exact name of the snipe key name.
#   Value1 is the "property" name, and the Value2 is the Rudder key name.
#
#   [api-mapping]
#       name = properties hostname
#       _snipeit_mac_address_1 = properties ipHostNumber
#       _snipeit_custom_name_1234567890 = properties custom_property
#
#   A list of valid properties are available in the Rudder API documentation
version = "1.0.0"

# Valid Rudder node properties that can be mapped
valid_properties = [
        "hostname",
        "osType", 
        "osName",
        "osVersion",
        "osKernelVersion",
        "machineType",
        "manufacturer",
        "serialNumber",
        "memorySize",
        "ipHostNumber",
        "timezone",
        "agentName",
        "policyServerId",
        "inventoryDate",
        "receiveDate"
]

# Import all the things
import json
import time
import configparser
import argparse
import logging
import datetime
from requests import Session
from requests.adapters import HTTPAdapter
from urllib3 import Retry

# Set us up for using runtime arguments by defining them.
runtimeargs = argparse.ArgumentParser()
runtimeargs.add_argument("-v", "--verbose", help="Sets the logging level to INFO and gives you a better idea of what the script is doing.", action="store_true")
runtimeargs.add_argument("--auto_incrementing", help="You can use this if you have auto-incrementing enabled in your snipe instance to utilize that instead of adding the Rudder ID for the asset tag.", action="store_true")
runtimeargs.add_argument("--dryrun", help="This checks your config and tries to contact both the Rudder and Snipe-it instances, and will generate the assets for debugging, but not update or sync anything but exits before updating or syncing any assets.", action="store_true")
runtimeargs.add_argument("--connection_test", help="This checks your config and tries to contact both the Rudder and Snipe-it instances.", action="store_true")
runtimeargs.add_argument("-d", "--debug", help="Sets logging to include additional DEBUG messages.", action="store_true")
runtimeargs.add_argument("--do_not_update_rudder", help="Does not update Rudder with the asset tags stored in Snipe.", action="store_false")
runtimeargs.add_argument('--do_not_verify_ssl', help="Skips SSL verification for all requests. Helpful when you use self-signed certificate.", action="store_false")
runtimeargs.add_argument("-r", "--ratelimited", help="Puts a half second delay between API calls to adhere to the standard 120/minute rate limit", action="store_true")
runtimeargs.add_argument("-f", "--force", help="Updates the Snipe asset with information from Rudder every time, despite what the timestamps indicate.", action="store_true")
runtimeargs.add_argument("--version", help="Prints the version and exits.", action="store_true")
user_opts = runtimeargs.add_mutually_exclusive_group()
user_opts.add_argument("-u", "--users", help="Checks out the item to the current user in Rudder if it's not already deployed", action="store_true")
user_opts.add_argument("-ui", "--users_inverse", help="Checks out the item to the current user in Rudder if it's already deployed", action="store_true")
user_opts.add_argument("-uf", "--users_force", help="Checks out the item to the user specified in Rudder no matter what", action="store_true")
runtimeargs.add_argument("-uns", "--users_no_search", help="Doesn't search for any users if the specified fields in Rudder and Snipe don't match. (case insensitive)", action="store_true")
user_args = runtimeargs.parse_args()

if user_args.version:
    print(version)
    raise SystemExit

# Notify users they're going to get a wall of text in verbose mode.
if user_args.debug:
    logging.basicConfig(level=logging.DEBUG)
elif user_args.verbose:
    logging.basicConfig(level=logging.INFO)
else:
    logging.basicConfig(level=logging.WARNING)

# Notify users if we're doing a connection test.
if user_args.connection_test and user_args.dryrun:
    logging.error("You can't use --connection_test and --dryrun at the same time. Please choose one or the other.")
    raise SystemExit("Error: Invalid runtime arguments - Exiting.")
if user_args.connection_test and user_args.force:
    logging.error("You can't use --connection_test and --force at the same time. Please choose one or the other.")
    raise SystemExit("Error: Invalid runtime arguments - Exiting.")
if user_args.connection_test:
    print("Connection test: Starting rudder2snipe with a connection test where we'll try to contact both the Rudder and Snipe-it instances.")

# Notify users if we're doing a dry run.
if user_args.dryrun and user_args.force:
    print("Running a dry run with force enabled. This will generate assets for debugging, but not update or sync anything.")
elif user_args.dryrun:
    print("Dryrun: Starting rudder2snipe with a dry run where no assets will be updated.")

# Find a valid settings.conf file.
logging.info("Searching for a valid settings.conf file.")
config = configparser.ConfigParser()
logging.debug("Checking for a settings.conf in /opt/rudder2snipe ...")
config.read("/opt/rudder2snipe/settings.conf")
if 'snipe-it' not in set(config):
    logging.debug("No valid config found in: /opt Checking for a settings.conf in /etc/rudder2snipe ...")
    config.read('/etc/rudder2snipe/settings.conf')
if 'snipe-it' not in set(config):
    logging.debug("No valid config found in /etc Checking for a settings.conf in current directory ...")
    config.read("settings.conf")
if 'snipe-it' not in set(config):
    logging.debug("No valid config found in current folder.")
    logging.error("No valid settings.conf was found. We'll need to quit while you figure out where the settings are at. You can check the README for valid locations.")
    raise SystemExit("Error: No valid settings.conf - Exiting.")

logging.info("Great, we found a settings file. Let's get started by parsing all of the settings.")

# While setting the variables, use a try loop so we can raise a error if something goes wrong.
try:
    # Set some Variables from the settings.conf:
    # This is the address, cname, or FQDN for your Rudder instance.
    logging.info("Setting the Rudder Base url.")
    rudder_base = config['rudder']['url']
    logging.debug("The configured Rudder base url is: {}".format(rudder_base))

    logging.info("Setting the API token for Rudder.")
    rudder_api_token = config['rudder']['api_token']
    logging.debug("The API token you provided for Rudder is: {}".format(rudder_api_token[:8] + "..."))

    # This is the address, cname, or FQDN for your snipe-it instance.
    logging.info("Setting the base URL for SnipeIT.")
    snipe_base = config['snipe-it']['url']
    logging.debug("The configured Snipe-IT base url is: {}".format(snipe_base))

    logging.info("Setting the API key for SnipeIT.")
    snipe_apiKey = config['snipe-it']['apikey']
    logging.debug("The API key you provided for Snipe is: {}".format(snipe_apiKey[:8] + "..."))

    logging.info("Setting the default status for SnipeIT assets.")
    defaultStatus = config['snipe-it']['defaultStatus']
    logging.debug("The default status we'll be setting updated assets to is: {} (I sure hope this is a number or something is probably wrong)".format(defaultStatus))

    logging.info("Setting the Snipe ID for default Manufacturer devices.")
    default_manufacturer_id = config['snipe-it']['manufacturer_id']
    logging.debug("The configured manufacturer ID for devices in snipe is: {} (Pretty sure this needs to be a number too)".format(default_manufacturer_id))

except:
    logging.error("Some of the required settings from the settings.conf were missing or invalid. Re-run rudder2snipe with the --verbose or --debug flag to get more details on which setting is missing or misconfigured.")
    raise SystemExit("Error: Missing or invalid settings in settings.conf - Exiting.")

# Check the config file for correct headers
SETTINGS_CORRECT = True
if not 'user-mapping' in config and (user_args.users or user_args.users_force or user_args.users_inverse):
    logging.error("""You've chosen to check out assets to users in some capacity using a cmdline switch, but not specified how you want to
    search Snipe IT for the users from Rudder. Make sure you have a 'user-mapping' section in your settings.conf file.""")
    SETTINGS_CORRECT = False
if snipe_base.endswith("/"):
    logging.error("""You have a trailing forward slash in the snipe url. Please remove it.""")
    SETTINGS_CORRECT = False
if rudder_base.endswith("/"):
    logging.error("""You have a trailing forward slash in the Rudder url. Please remove it.""")
    SETTINGS_CORRECT = False

if not SETTINGS_CORRECT:
    raise SystemExit

# Check the config file for valid Rudder properties.
logging.debug("Checking the settings.conf file for valid Rudder properties so mapping can occur properly.")
for key in config['api-mapping']:
    rudder_split = config['api-mapping'][key].split()
    if rudder_split[0] == 'properties' and len(rudder_split) > 1:
        if rudder_split[1] in valid_properties:
            logging.info('Found property {}: Acceptable'.format(rudder_split[1]))
            continue
        else:
            logging.warning("Found property: {} which might not be a standard Rudder property. Please verify.".format(rudder_split[1]))
    else:
        logging.info('Found mapping {}: Will verify at runtime'.format(rudder_split[0]))

### Setup Some Functions ###
api_count = 0
first_api_call = None

# Headers for the API call.
logging.info("Creating the headers we'll need for API calls")
rudder_headers = {'X-API-Token': rudder_api_token, 'Accept': 'application/json', 'Content-Type': 'application/json'}
snipe_headers = {'Authorization': 'Bearer {}'.format(snipe_apiKey), 'Accept': 'application/json', 'Content-Type': 'application/json'}
logging.debug('Request headers for Rudder will be: {}\nRequest headers for Snipe will be: {}'.format(rudder_headers, snipe_headers))

session = Session()
retries = Retry(
    total=3,
    allowed_methods={'GET'},
)
session.mount('https://', HTTPAdapter(max_retries=retries))

# This function is run every time a request is made, handles rate limiting for Snipe IT.
def request_handler(r, *args, **kwargs):
    global api_count
    global first_api_call

    # Slow and steady wins the race. Limit all API calls (not just to snipe) to the Rate limit.
    if user_args.ratelimited:
        if '"messages":429' in r.text:
            logging.warn("Despite respecting the rate limit of Snipe, we've still been limited. Trying again after sleeping for 2 seconds.")
            time.sleep(2)
            re_req = r.request
            return session.send(re_req)
        if api_count == 0:
            first_api_call = time.time()
            time.sleep(0.5)
        api_count += 1
        time_elapsed = (time.time() - first_api_call)
        api_rate = api_count / time_elapsed
        if api_rate > 1.95:
            sleep_time = 0.5 + (api_rate - 1.95)
            logging.debug('Going over snipe rate limit of 120/minute ({}/minute), sleeping for {}'.format(api_rate, sleep_time))
            time.sleep(sleep_time)
        logging.debug("Made {} requests to Snipe IT in {} seconds, with a request being sent every {} seconds".format(api_count, time_elapsed, api_rate))
    if '"messages":429' in r.text:
        logging.error(r.content)
        raise SystemExit("We've been rate limited. Use option -r to respect the built in Snipe IT API rate limit of 120/minute.")
    return r

# Function to make the API call for all Rudder nodes
def get_rudder_nodes():
    api_url = '{}/rudder/api/latest/nodes'.format(rudder_base)
    logging.debug('Calling for Rudder nodes against: {}\n The API token and headers for this GET request can be found near the beginning of the output.'.format(api_url))
    response = session.get(api_url, headers=rudder_headers, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        logging.debug("Got back a valid 200 response code.")
        return response.json()
    else:
        logging.warning('Received an invalid status code when trying to retrieve Rudder Node list:{} - {}'.format(response.status_code, response.content))
        logging.debug("Returning a null value for the function.")
        return None

# Function to lookup a Rudder node by id with detailed information.
def search_rudder_node(node_id):
    api_url = "{}/rudder/api/latest/nodes/{}".format(rudder_base, node_id)
    response = session.get(api_url, headers=rudder_headers, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        logging.debug("Got back a valid 200 response code.")
        jsonresponse = response.json()
        logging.debug("Returning: {}".format(jsonresponse['data']['nodes'][0]))
        return jsonresponse['data']['nodes'][0]
    else:
        logging.warning('Rudder responded with error code:{} when we tried to look up id: {}'.format(response.status_code, node_id))
        logging.debug("Returning a null value for the function.")
        return None

# Function to lookup a snipe asset by serial number.
def search_snipe_asset(serial):
    api_url = '{}/api/v1/hardware/byserial/{}'.format(snipe_base, serial)
    response = session.get(api_url, headers=snipe_headers, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        jsonresponse = response.json()
        # Check to make sure there's actually a result
        if "total" in jsonresponse:
            if jsonresponse['total'] == 1:
                return jsonresponse
            elif jsonresponse['total'] == 0:
                logging.info("No assets match {}".format(serial))
                return "NoMatch"
            else:
                logging.warning('FOUND {} matching assets while searching for: {}'.format(jsonresponse['total'], serial))
                return "MultiMatch"
        else:
            logging.info("No assets match {}".format(serial))
            return "NoMatch"
    else:
        logging.warning('Snipe-IT responded with error code:{} when we tried to look up: {}'.format(response.text, serial))
        logging.debug('{} - {}'.format(response.status_code, response.content))
        return "ERROR"

# Function to get all the asset models
def get_snipe_models():
    api_url = '{}/api/v1/models'.format(snipe_base)
    logging.debug('Calling against: {}'.format(api_url))
    response = session.get(api_url, headers=snipe_headers, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        jsonresponse = response.json()
        logging.info("Got a valid response that should have {} models.".format(jsonresponse['total']))
        if jsonresponse['total'] <= len(jsonresponse['rows']):
            return jsonresponse
        else:
            logging.info("We didn't get enough results so we need to get them again.")
            api_url = '{}/api/v1/models?limit={}'.format(snipe_base, jsonresponse['total'])
            newresponse = session.get(api_url, headers=snipe_headers, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
            if response.status_code == 200:
                newjsonresponse = newresponse.json()
                if newjsonresponse['total'] == len(newjsonresponse['rows']):
                    return newjsonresponse
                else:
                    logging.error("We couldn't seem to get all of the model numbers")
                    raise SystemExit("Unable to get all model objects from Snipe-IT instance")
            else:
                logging.error('When we tried to retrieve a list of models, Snipe-IT responded with error status code:{} - {}'.format(response.status_code, response.content))
                raise SystemExit("Snipe models API endpoint failed.")
    else:
        logging.error('When we tried to retrieve a list of models, Snipe-IT responded with error status code:{} - {}'.format(response.status_code, response.content))
        raise SystemExit("Snipe models API endpoint failed.")

# Recursive function returns all users in a Snipe Instance, 100 at a time.
def get_snipe_users(previous=[]):
    user_id_url = '{}/api/v1/users'.format(snipe_base)
    payload = {
        'limit': 100,
        'offset': len(previous)
    }
    logging.debug('The payload for the snipe users GET is {}'.format(payload))
    response = session.get(user_id_url, headers=snipe_headers, params=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    response_json = response.json()
    current = response_json['rows']
    if len(previous) != 0:
        current = previous + current
    if response_json['total'] > len(current):
        logging.debug('We have more than 100 users, get the next page - total: {} current: {}'.format(response_json['total'], len(current)))
        return get_snipe_users(current)
    else:
        return current

# Function to search snipe for a user
def get_snipe_user_id(username):
    if username == '':
        return "NotFound"
    username = username.lower()
    for user in snipe_users:
        for value in user.values():
            if str(value).lower() == username:
                id = user['id']
                return id
    if user_args.users_no_search:
        logging.debug("No matches in snipe_users for {}, not querying the API for the next closest match since we've been told not to".format(username))
        return "NotFound"
    logging.debug('No matches in snipe_users for {}, querying the API for the next closest match'.format(username))
    user_id_url = '{}/api/v1/users'.format(snipe_base)
    payload = {
        'search': username,
        'limit': 1,
        'sort': 'username',
        'order': 'asc'
    }
    logging.debug('The payload for the snipe user search is: {}'.format(payload))
    response = session.get(user_id_url, headers=snipe_headers, params=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    try:
        return response.json()['rows'][0]['id']
    except:
        return "NotFound"

# Function that creates a new Snipe Model - not an asset - with a JSON payload
def create_snipe_model(payload):
    api_url = '{}/api/v1/models'.format(snipe_base)
    logging.debug('Calling to create new snipe model type against: {}\nThe payload for the POST request is:{}\nThe request headers can be found near the start of the output.'.format(api_url, payload))
    response = session.post(api_url, headers=snipe_headers, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    if response.status_code == 200:
        jsonresponse = response.json()
        modelnumbers[jsonresponse['payload']['model_number']] = jsonresponse['payload']['id']
        return True
    else:
        logging.warning('Error code: {} while trying to create a new model.'.format(response.status_code))
        return False

# Function to create a new asset by passing array
def create_snipe_asset(payload):
    api_url = '{}/api/v1/hardware'.format(snipe_base)
    logging.debug('Calling to create a new asset against: {}\nThe payload for the POST request is:{}\nThe request headers can be found near the start of the output.'.format(api_url, payload))
    response = session.post(api_url, headers=snipe_headers, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    logging.debug(response.text)
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - {}".format(response.content))
        jsonresponse = response.json()
        if jsonresponse['status'] == "error":
            logging.error('Asset creation failed for asset {} with error {}'.format(payload['name'], jsonresponse['messages']))
            return 'ERROR', response
        return 'AssetCreated', response
    else:
        logging.error('Asset creation failed for asset {} with error {}'.format(payload['name'], response.text))
        return 'ERROR', response

# Function that updates a snipe asset with a JSON payload
def update_snipe_asset(snipe_id, payload):
    if user_args.dryrun:
        logging.debug("Dry run mode is enabled. We would have updated ID: {} with the following payload: {}".format(snipe_id, payload))
        return True
    api_url = '{}/api/v1/hardware/{}'.format(snipe_base, snipe_id)
    logging.debug('The payload for the snipe update is: {}'.format(payload))
    response = session.patch(api_url, headers=snipe_headers, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    # Verify that the payload updated properly.
    goodupdate = True
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - Checking the payload updated properly: If you error here it's because you configure the API mapping right.")
        jsonresponse = response.json()
        # Check if there's an Error and Log it, or parse the payload.
        if jsonresponse['status'] == "error":
            logging.error('Unable to update ID: {}. Error "{}"'.format(snipe_id, jsonresponse['messages']))
            goodupdate = False
        else:
            for key in payload:
                if key == 'purchase_date':
                    payload[key] = payload[key] + " 00:00:00"
                if payload[key] == '':
                    payload[key] = None
                if jsonresponse['payload'][key] != payload[key]:
                    logging.warning('Unable to update ID: {}. We failed to update the {} field with "{}"'.format(snipe_id, key, payload[key]))
                    goodupdate = False
                else:
                    logging.info("Successfully updated {} with: {}".format(key, payload[key]))
        return goodupdate
    else:
        logging.error('Whoops. Got an error status code while updating ID {}: {} - {}'.format(snipe_id, response.status_code, response.content))
        return False

# Function that checks in an asset in snipe
def checkin_snipe_asset(asset_id):
    api_url = '{}/api/v1/hardware/{}/checkin'.format(snipe_base, asset_id)
    payload = {
        'note': 'checked in by script from Rudder'
    }
    logging.debug('The payload for the snipe checkin is: {}'.format(payload))
    response = session.post(api_url, headers=snipe_headers, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    logging.debug('The response from Snipe IT is: {}'.format(response.json()))
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - {}".format(response.content))
        return "CheckedOut"
    else:
        return response

# Function that checks out an asset in snipe
def checkout_snipe_asset(user, asset_id, checked_out_user=None):
    logging.debug('Asset {} is being checked out to {}'.format(user, asset_id))
    user_id = get_snipe_user_id(user)
    if user_id == 'NotFound':
        logging.info("User {} not found".format(user))
        return "NotFound"
    if checked_out_user == None:
        logging.info("Not checked out, checking out to {}".format(user))
    elif checked_out_user == "NewAsset":
        logging.info("First time this asset will be checked out, checking out to {}".format(user))
    elif checked_out_user['id'] == user_id:
        logging.info(str(asset_id) + " already checked out to user " + user)
        return 'CheckedOut'
    else:
        logging.info("Checking in {} to check it out to {}".format(asset_id, user))
        checkin_snipe_asset(asset_id)
    api_url = '{}/api/v1/hardware/{}/checkout'.format(snipe_base, asset_id)
    logging.info("Checking out {} to check it out to {}".format(asset_id, user))
    payload = {
        'checkout_to_type': 'user',
        'assigned_user': user_id,
        'note': 'Assignment made automatically, via script from Rudder.'
    }
    logging.debug('The payload for the snipe checkin is: {}'.format(payload))
    response = session.post(api_url, headers=snipe_headers, json=payload, verify=user_args.do_not_verify_ssl, hooks={'response': request_handler})
    logging.debug('The response from Snipe IT is: {}'.format(response.json()))
    if response.status_code == 200:
        logging.debug("Got back status code: 200 - {}".format(response.content))
        return "CheckedOut"
    else:
        logging.error('Asset checkout failed for asset {} with error {}'.format(asset_id, response.text))
        return response

### Run Testing ###
# Report if we're verifying SSL or not.
logging.info("SSL Verification is set to: {}".format(user_args.do_not_verify_ssl))

# Do some tests to see if the hosts are up. Don't use hooks for these as we don't have tokens yet.
logging.info("Running tests to see if hosts are up.")
try:
    SNIPE_UP = True if session.get(snipe_base, verify=user_args.do_not_verify_ssl).status_code == 200 else False
except Exception as e:
    logging.exception(e)
    SNIPE_UP = False
try:
    RUDDER_UP = True if session.get(rudder_base, verify=user_args.do_not_verify_ssl).status_code in (200, 401) else False
except Exception as e:
    logging.exception(e)
    RUDDER_UP = False

if not SNIPE_UP:
    logging.error('Snipe-IT looks like it is down from here. \nPlease check your config in the settings.conf file, or your instance.')
else:
    logging.info('We were able to get a good response from your Snipe-IT instance.')
if not RUDDER_UP:
    logging.error('Rudder looks down from here. \nPlease check the your config in the settings.conf file, or your hosted Rudder instance.')
else:
    logging.info('We were able to get a good response from your Rudder instance.')

# Exit if you can't contact SNIPE or Rudder
if (RUDDER_UP == False) or (SNIPE_UP == False):
    raise SystemExit("Error: Host could not be contacted.")

logging.info("Finished running our tests.")

### Get Started ###
# Get a list of known models from Snipe
logging.info("Getting a list of computer models that snipe knows about.")
snipemodels = get_snipe_models()
logging.debug("Parsing the {} model results for models with model numbers.".format(len(snipemodels['rows'])))
modelnumbers = {}
for model in snipemodels['rows']:
    if model['model_number'] == "":
        logging.debug("The model, {}, did not have a model number. Skipping.".format(model['name']))
        continue
    modelnumbers[model['model_number']] = model['id']
logging.info("Our list of models has {} entries.".format(len(modelnumbers)))
logging.debug("Here's the list of the {} models and their id's that we were able to collect:\n{}".format(len(modelnumbers), modelnumbers))

# Get the IDS of all active nodes from Rudder.
rudder_node_list = get_rudder_nodes()

# Get a list of users from Snipe if the user has specified they're syncing users
if user_args.users or user_args.users_force or user_args.users_inverse:
    snipe_users = get_snipe_users()

TotalNumber = 0
if rudder_node_list and 'data' in rudder_node_list and 'nodes' in rudder_node_list['data']:
    TotalNumber = len(rudder_node_list['data']['nodes'])

# Make sure we have a good list.
if rudder_node_list != None:
    logging.info('Received a list of Rudder nodes that had {} entries.'.format(TotalNumber))
else:
    logging.error("We were not able to retrieve a list of nodes from your Rudder instance. It's likely that your settings, or credentials are incorrect. Check your settings.conf and verify you can make API calls outside of this system with the credentials found in your settings.conf")
    raise SystemExit("Unable to get Rudder Nodes.")

# After this point we start editing data, so quit if this is a dryrun
if user_args.connection_test:
    raise SystemExit("Connection Test: Complete.")

# From this point on, we're editing data.
logging.info('Starting to Update Inventory')
CurrentNumber = 0

for rudder_node in rudder_node_list['data']['nodes']:
    CurrentNumber += 1
    logging.info("Processing entry {} out of {} - RudderID: {} - NAME: {}".format(CurrentNumber, TotalNumber, rudder_node['id'], rudder_node['hostname']))
    
    # Get detailed information for this node
    rudder = search_rudder_node(rudder_node['id'])
    if rudder == None:
        continue

    # Extract properties for easier access
    properties = rudder.get('properties', [])
    property_dict = {}
    for prop in properties:
        property_dict[prop['name']] = prop['value']

    # If the entry doesn't contain a serial, then we need to skip this entry.
    serial_number = property_dict.get('serialNumber', '')
    if serial_number == '' or serial_number == 'Not Available' or serial_number == None:
        logging.warning("The serial number is not available in Rudder for node {}. Since there's no serial number, we'll skip it for now.".format(rudder['id']))
        continue

    # Check that the model number exists in snipe, if not create it.
    machine_type = property_dict.get('machineType', 'Unknown')
    manufacturer = property_dict.get('manufacturer', 'Unknown')
    
    if machine_type not in modelnumbers and machine_type != 'Unknown':
        logging.info("Could not find a model ID in snipe for: {}".format(machine_type))
        newmodel = {
            "category_id": config['snipe-it']['computer_model_category_id'],
            "manufacturer_id": default_manufacturer_id,
            "name": machine_type,
            "model_number": machine_type
        }
        if 'computer_custom_fieldset_id' in config['snipe-it']:
            fieldset_split = config['snipe-it']['computer_custom_fieldset_id']
            newmodel['fieldset_id'] = fieldset_split
        create_snipe_model(newmodel)

    # Pass the SN from Rudder to search for a match in Snipe
    snipe = search_snipe_asset(serial_number)

    # Create a new asset if there's no match:
    if snipe == 'NoMatch':
        logging.info("Creating a new asset in snipe for Rudder ID {} - {}".format(rudder['id'], rudder['hostname']))
        
        # Create asset tag - use Rudder ID if no custom field specified
        rudder_asset_tag = None
        logging.debug('Checking settings.conf for asset tag configuration.')
        if 'asset_tag' in config['snipe-it']:
            tag_split = config['snipe-it']['asset_tag'].split()
            try:
                if tag_split[0] == 'properties':
                    rudder_asset_tag = property_dict.get(tag_split[1], '')
                else:
                    rudder_asset_tag = rudder.get(tag_split[0], {}).get(tag_split[1], '')
            except:
                rudder_asset_tag = 'rudderid-{}'.format(rudder['id'])
        
        if rudder_asset_tag == None or rudder_asset_tag == '':
            logging.debug('No custom configuration found in settings.conf for asset tag name upon asset creation.')
            rudder_asset_tag = 'rudderid-{}'.format(rudder['id'])
        
        # Create the payload
        logging.debug("Payload is being made for a Rudder node")
        newasset = {
            'asset_tag': rudder_asset_tag,
            'model_id': modelnumbers.get(machine_type, modelnumbers.get('Unknown', default_manufacturer_id)),
            'name': rudder['hostname'],
            'status_id': defaultStatus,
            'serial': serial_number
        }
        
        # Add mapped fields from api-mapping
        for snipekey in config['api-mapping']:
            rudder_split = config['api-mapping'][snipekey].split()
            try:
                if rudder_split[0] == 'properties':
                    rudder_value = property_dict.get(rudder_split[1], '')
                else:
                    # Navigate through nested structure
                    rudder_value = rudder
                    for part in rudder_split:
                        rudder_value = rudder_value.get(part, {})
                    if isinstance(rudder_value, dict):
                        rudder_value = ''
                
                if rudder_value:
                    newasset[snipekey] = rudder_value
            except (KeyError, TypeError):
                logging.debug("Skipping mapping for {}, Rudder field not found".format(snipekey))
                continue
        
        # Reset the payload without the asset_tag if auto_incrementing flag is set.
        if user_args.auto_incrementing:
            newasset.pop('asset_tag', None)
        
        new_snipe_asset = create_snipe_asset(newasset)
        logging.debug(new_snipe_asset)
        if new_snipe_asset[0] != "AssetCreated":
            continue
        
        if user_args.users or user_args.users_force or user_args.users_inverse:
            rudder_split = config['user-mapping']['rudder_api_field'].split()
            username = ''
            if rudder_split[0] == 'properties':
                username = property_dict.get(rudder_split[1], '')
            else:
                username = rudder.get(rudder_split[0], {}).get(rudder_split[1], '')
            
            if not username:
                logging.info("Couldn't find user information for this device, not checking it out.")
                continue
            
            logging.info('Checking out new item {} to user {}'.format(rudder['hostname'], username))
            checkout_snipe_asset(username, new_snipe_asset[1].json()['payload']['id'], "NewAsset")
    
    # Log an error if there's an issue, or more than once match.
    elif snipe == 'MultiMatch':
        logging.warning("WARN: You need to resolve multiple assets with the same serial number in your inventory. If you can't find them in your inventory, you might need to purge your deleted records. You can find that in the Snipe Admin settings. Skipping serial number {} for now.".format(serial_number))
    elif snipe == 'ERROR':
        logging.error("We got an error when looking up serial number {} in snipe, which shouldn't happen at this point. Check your snipe instance and setup. Skipping for now.".format(serial_number))

    else:
        # Only update if Rudder has more recent info.
        snipe_id = snipe['rows'][0]['id']
        snipe_time = snipe['rows'][0]['updated_at']['datetime']
        rudder_time = property_dict.get('inventoryDate', property_dict.get('receiveDate', ''))
        
        # Check to see that the Rudder record is newer than the previous Snipe update, or if it is a new record in Snipe
        if (rudder_time > snipe_time) or (user_args.force):
            if user_args.force:
                logging.debug("Forced the Update regardless of the timestamps below.")
            logging.debug("Updating the Snipe asset because Rudder has a more recent timestamp: {} > {} or the Snipe Record is new".format(rudder_time, snipe_time))
            updates = {}
            
            for snipekey in config['api-mapping']:
                try:
                    rudder_split = config['api-mapping'][snipekey].split()
                    if rudder_split[0] == 'properties':
                        rudder_value = property_dict.get(rudder_split[1], '')
                    else:
                        # Navigate through nested structure
                        rudder_value = rudder
                        for part in rudder_split:
                            rudder_value = rudder_value.get(part, {})
                        if isinstance(rudder_value, dict):
                            rudder_value = ''
                    
                    if not rudder_value:
                        continue
                        
                    payload = {snipekey: rudder_value}
                    latestvalue = rudder_value
                except (KeyError, TypeError):
                    logging.debug("Skipping the payload, because the Rudder key we're mapping to doesn't exist")
                    continue

                # Need to check that we're not needlessly updating the asset.
                # If it's a custom value it'll fail the first section and send it to except section that will parse custom sections.
                try:
                    if snipe['rows'][0][snipekey] != latestvalue:
                        updates.update(payload)
                    else:
                        logging.debug("Skipping the payload, because it already exists.")
                except:
                    logging.debug("The snipekey lookup failed, which means it's a custom field. Parsing those to see if it needs to be updated or not.")
                    needsupdate = False
                    for CustomField in snipe['rows'][0]['custom_fields']:
                        if snipe['rows'][0]['custom_fields'][CustomField]['field'] == snipekey:
                            if snipe['rows'][0]['custom_fields'][CustomField]['value'] != str(latestvalue):
                                logging.debug("Found the field, and the value needs to be updated from {} to {}".format(snipe['rows'][0]['custom_fields'][CustomField]['value'], latestvalue))
                                needsupdate = True
                    if needsupdate == True:
                        updates.update(payload)
                    else:
                        logging.debug("Skipping the payload, because it already exists, or the Snipe key we're mapping to doesn't.")

            if updates:
                update_snipe_asset(snipe_id, updates)

            if ((user_args.users or user_args.users_inverse) and (snipe['rows'][0]['assigned_to'] == None) == user_args.users) or user_args.users_force:
                if snipe['rows'][0]['status_label']['status_meta'] in ('deployable', 'deployed'):
                    rudder_split = config['user-mapping']['rudder_api_field'].split()
                    username = ''
                    if rudder_split[0] == 'properties':
                        username = property_dict.get(rudder_split[1], '')
                    else:
                        username = rudder.get(rudder_split[0], {}).get(rudder_split[1], '')
                    
                    if not username:
                        logging.info("Couldn't find user information for this device, not checking it out.")
                        continue
                    
                    checkout_snipe_asset(username, snipe_id, snipe['rows'][0]['assigned_to'])
                else:
                    logging.info("Can't checkout {} since the status isn't set to deployable".format(rudder['hostname']))

        else:
            logging.info("Snipe Record is newer than the Rudder record. Nothing to sync. If this wrong, then force an inventory update in Rudder")
            logging.debug("Not updating the Snipe asset because Snipe has a more recent timestamp: {} < {}".format(rudder_time, snipe_time))

logging.debug('Total amount of API calls made: {}'.format(api_count))
